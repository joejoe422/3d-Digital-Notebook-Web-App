<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Phaser Lane Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #f0f0f0;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.85.0/dist/phaser.min.js"></script>
</head>
<body>
    <script>
        const config = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            scene: {
                preload: preload,
                create: create,
                update: update
            },
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 0 },
                    debug: false
                }
            }
        };

        const game = new Phaser.Game(config);

        let player, bots, orbs, obstacles, trail, timerText, cursors;
        let gameTime = 0;
        let gameOver = false;
        const laneTopWidth = 700;
        const laneBottomWidth = 150;
        const laneTopX = (config.width - laneTopWidth) / 2;
        const laneBottomX = (config.width - laneBottomWidth) / 2;
        const scrollSpeed = 3;

        function preload() {
            // Load placeholder assets (replace with actual sprite sheets and sounds)
            this.load.image('player', 'https://via.placeholder.com/40x60/00f.png?text=Player');
            this.load.image('bot', 'https://via.placeholder.com/40x60/ff8c00.png?text=Bot');
            this.load.image('orb', 'https://via.placeholder.com/50/0f0.png?text=Orb');
            this.load.image('obstacle', 'https://via.placeholder.com/40/ff0000.png?text=Obstacle');
            this.load.audio('collect', 'https://freesound.org/data/previews/0/0_1.mp3'); // Placeholder sound
        }

        function create() {
            // Background
            this.cameras.main.setBackgroundColor('#0a0');

            // Draw lane (perspective effect)
            const laneGraphics = this.add.graphics();
            laneGraphics.fillStyle(0x555555, 1);
            laneGraphics.beginPath();
            laneGraphics.moveTo(laneTopX, 0);
            laneGraphics.lineTo(laneTopX + laneTopWidth, 0);
            laneGraphics.lineTo(laneBottomX + laneBottomWidth, config.height);
            laneGraphics.lineTo(laneBottomX, config.height);
            laneGraphics.closePath();
            laneGraphics.fillPath();

            // Tiled pattern
            const tileSize = 20;
            for (let y = 0; y < config.height; y += tileSize) {
                const laneWidthAtY = laneTopWidth + (laneBottomWidth - laneTopWidth) * (y / config.height);
                const laneLeftAtY = (config.width - laneWidthAtY) / 2;
                for (let x = laneLeftAtY; x < laneLeftAtY + laneWidthAtY; x += tileSize) {
                    laneGraphics.lineStyle(1, 0x777777, 1);
                    laneGraphics.strokeRect(x, y, tileSize, tileSize);
                }
            }

            // Dashed line
            const dashedLine = this.add.graphics();
            dashedLine.lineStyle(5, 0xffffff, 1);
            dashedLine.setLineDash([10, 15]);
            dashedLine.beginPath();
            dashedLine.moveTo(config.width / 2, 0);
            dashedLine.lineTo(config.width / 2, config.height);
            dashedLine.strokePath();

            // Player
            player = this.physics.add.sprite(config.width / 2, 500, 'player');
            player.setData('score', 0);
            player.setScale(0.8);
            player.setCollideWorldBounds(true);

            // Bots
            bots = this.physics.add.group();
            bots.create(config.width / 2 - 150, 400, 'bot').setData('score', 1000).setScale(0.8);
            bots.create(config.width / 2 + 150, 300, 'bot').setData('score', 856).setScale(0.8);

            // Orbs
            orbs = this.physics.add.group();
            orbs.create(config.width / 2, 200, 'orb').setData('value', 1064).setScale(0.8);

            // Obstacles
            obstacles = this.physics.add.group();

            // Trail (using particles)
            trail = this.add.particles(0, 0, 'player', {
                speed: 0,
                lifespan: 500,
                blendMode: 'ADD',
                scale: { start: 0.2, end: 0 },
                frequency: 50,
                emitZone: { type: 'edge', source: new Phaser.Geom.Rectangle(-5, -5, 10, 10), quantity: 1 }
            });
            trail.startFollow(player);

            // Timer
            timerText = this.add.text(10, 10, '00:00', { font: '16px Arial', fill: '#fff' });

            // Controls
            cursors = this.input.keyboard.createCursorKeys();

            // Collisions
            this.physics.add.overlap(player, orbs, collectOrb, null, this);
            this.physics.add.overlap(player, obstacles, hitObstacle, null, this);

            // Spawn timers
            this.time.addEvent({ delay: 2000, callback: spawnOrb, callbackScope: this, loop: true });
            this.time.addEvent({ delay: 4000, callback: spawnObstacle, callbackScope: this, loop: true });
        }

        function update(time, delta) {
            if (gameOver) return;

            // Update timer
            gameTime += delta / 1000;
            const minutes = Math.floor(gameTime / 60).toString().padStart(2, '0');
            const seconds = Math.floor(gameTime % 60).toString().padStart(2, '0');
            timerText.setText(`${minutes}:${seconds}`);

            // Player movement
            if (cursors.left.isDown) {
                player.setVelocityX(-200);
                const laneWidthAtPlayerY = laneTopWidth + (laneBottomWidth - laneTopWidth) * (player.y / config.height);
                const laneLeftAtPlayerY = (config.width - laneWidthAtPlayerY) / 2;
                if (player.x < laneLeftAtPlayerY) player.x = laneLeftAtPlayerY;
            } else if (cursors.right.isDown) {
                player.setVelocityX(200);
                const laneWidthAtPlayerY = laneTopWidth + (laneBottomWidth - laneTopWidth) * (player.y / config.height);
                const laneRightAtPlayerY = (config.width + laneWidthAtPlayerY) / 2;
                if (player.x > laneRightAtPlayerY) player.x = laneRightAtPlayerY;
            } else {
                player.setVelocityX(0);
            }
            if (cursors.up.isDown && player.y > 50) {
                player.setVelocityY(-200);
            } else if (cursors.down.isDown && player.y < config.height - 50) {
                player.setVelocityY(200);
            } else {
                player.setVelocityY(0);
            }

            // Move bots
            bots.children.entries.forEach(bot => {
                bot.y -= scrollSpeed;
                bot.x += Math.sin(time * 0.001 + bot.y) * 2;
                const laneWidthAtBotY = laneTopWidth + (laneBottomWidth - laneTopWidth) * (bot.y / config.height);
                const laneLeftAtBotY = (config.width - laneWidthAtBotY) / 2;
                bot.x = Math.max(laneLeftAtBotY, Math.min(laneLeftAtBotY + laneWidthAtBotY, bot.x));
                if (bot.y < -50) {
                    bot.y = config.height + 10;
                    bot.x = laneTopX + Math.random() * laneTopWidth;
                }
            });

            // Move orbs and obstacles
            orbs.children.entries.forEach(orb => {
                orb.y += scrollSpeed;
                if (orb.y > config.height) orb.destroy();
                // Display orb value
                if (!orb.scoreText) {
                    orb.scoreText = this.add.text(orb.x - 30, orb.y + 8, orb.getData('value'), { font: 'bold 24px Arial', fill: '#fff' });
                }
                orb.scoreText.setPosition(orb.x - 30, orb.y + 8);
            });

            obstacles.children.entries.forEach(obstacle => {
                obstacle.y += scrollSpeed;
                if (obstacle.y > config.height) obstacle.destroy();
            });

            // Display scores on characters
            bots.children.entries.forEach(bot => {
                if (!bot.scoreText) {
                    bot.scoreText = this.add.text(bot.x - 30, bot.y - 40, bot.getData('score'), { font: 'bold 24px Arial', fill: '#fff' });
                }
                bot.scoreText.setPosition(bot.x - 30, bot.y - 40);
            });

            if (!player.scoreText) {
                player.scoreText = this.add.text(player.x - 30, player.y - 40, player.getData('score'), { font: 'bold 24px Arial', fill: '#fff' });
            }
            player.scoreText.setPosition(player.x - 30, player.y - 40);
        }

        function collectOrb(player, orb) {
            player.setData('score', player.getData('score') + orb.getData('value'));
            orb.scoreText.destroy();
            orb.destroy();
            this.sound.play('collect');
        }

        function hitObstacle(player, obstacle) {
            gameOver = true;
            this.add.text(200, 300, 'Game Over! Score: ' + player.getData('score'), { font: '40px Arial', fill: '#000' });
            this.physics.pause();
        }

        function spawnOrb() {
            if (gameOver) return;
            const spawnX = laneTopX + Math.random() * laneTopWidth;
            const orb = orbs.create(spawnX, -10, 'orb');
            orb.setData('value', Math.floor(Math.random() * 500) + 500);
            orb.setScale(0.8);
        }

        function spawnObstacle() {
            if (gameOver) return;
            const spawnX = laneTopX + Math.random() * laneTopWidth;
            obstacles.create(spawnX, -10, 'obstacle').setScale(0.8);
        }
    </script>
</body>
</html>